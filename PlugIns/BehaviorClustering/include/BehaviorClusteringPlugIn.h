// ----------------------------------------------------------------------------
// This source file is part of BehaveRT 
// http://isis.dia.unisa.it/projects/behavert/
//
// Copyright (c) 2008-2010 ISISLab - University of Salerno
// Original author: Bernardino Frola <frola@dia.unisa.it>
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense,
// and/or sell copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
// THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//
// ----------------
// Change log
//
//	  03-10 bf: Created
// 23-10-10 bf: Local propagation/cluster indentification
//
// ----------------

#pragma once

#include "BehaveRT.h"
#include "BehaviorClustering_kernel.cuh"
#include "BCShaders.h"

#include <fstream>
#include <iostream>
#include <algorithm>


/// Autogenerated namespace
namespace BehaviorClustering
{
	/**
		\brief Put here brief the description of the plugIn
		
		Put here the detailed description of the plugIn
	*/
	template <class Super>
	class BehaviorClusteringPlugIn: public Super, public SimEnginePlugIn
	{
	public:
		// /////////////////////////////////////////////////////
		// Constructor/Descructor

		/// Defautl constructor: provides plugIn installation
		BehaviorClusteringPlugIn() { SimEnginePlugIn::installPlugIn(); }

		/// Defautl constructor: provides plugIn uninstallation
		~BehaviorClusteringPlugIn() { SimEnginePlugIn::uninstallPlugIn(); }
		
		const std::string name() { return "BehaviorClusteringPlugIn"; }	

		/// Dependeciens: none
		const DependenciesList plugInDependencies() 
		{ 
			DependenciesList dependencies;
			dependencies.push_back("OpenSteerWrapperPlugIn");
			dependencies.push_back("Drawable3DPlugIn");
			return dependencies;	
		}

		// ////////////////////////////////////////////////////
		// Methods
	private:
		/// @override
		void install();
		
		/// @override
		void uninstall();

	public:
		/// @override
		void reset();

		/// @override
		void update(const float elapsedTime);

		// Custom operations
	public:

		int getElementsNumber() { return hBehaviorClusteringParams.elementsNumber; }
		void changeShowClusterMembershipStats()
			{ m_ShowClusterMembershipStats = !m_ShowClusterMembershipStats; }

		// Put here the functionalities
		void steerForClustering();
		void steerForClustering2();
		void analyzeClusterHitRate();

		void mergeClusters();
		void freezeClusters();

		// ---------------
		// MOD 24-10-10
		void computeClusterMembership();
		void drawClusterMemberships();
		// ---------------

		BehaveRT::DeviceArrayWrapper<float3>* getClusterMembership() 
			{ return m_ClusterMembership; }

		std::string getDatasetPath() { return m_DatasetPath; } 

		// ////////////////////////////////////////////////////
		// Fields

		
	protected:
		// Put here features

		BehaveRT::DeviceArrayWrapper<float>* m_FeaturesVector;
		BehaveRT::DeviceArrayWrapper<float4>* m_SimilarityStats;
		BehaveRT::DeviceArrayWrapper<float3>* m_ClusterMembership;

		// ---------------
		// MOD 24-10-10
		BehaveRT::DeviceArrayWrapper<float4>* m_CMConnector; // Cluster membership connector
		// ---------------

		// Two-ste
		BehaveRT::DeviceArrayWrapper<float4>* m_NieghSimilarities;

		std::string m_DatasetPath;
		std::string m_DatasetLabels;

		int m_AttributesToIgnoreAtStart;
		int m_AttributesToIgnoreAtEnd;

		int m_NeededNumBodies;

		bool m_ShowClusterMembershipStats;
	};
}

using namespace BehaviorClustering;

// --------------------------------------------------------------
// --------------------------------------------------------------
// --------------------------------------------------------------
// Implementation
template <class Super>
void BehaviorClusteringPlugIn<Super>::install()
{
	// Params
	read_config_param(BehaviorClustering, clusteringForceParams, Float3);
	read_config_param(BehaviorClustering, alignmentClusteringForceParams, Float3);
	read_config_param(BehaviorClustering, featuresCount, Int);
	read_config_param(BehaviorClustering, similarityStatsParams, Float3);

	hBehaviorClusteringParams.avgSimilarityController = 1.0f;
	hBehaviorClusteringParams.sameClusterMaxRadius = 1.5f;

	m_AttributesToIgnoreAtStart = 
		BehaveRT::StringConverter::parseInt(
			m_CommonRes.getConfig()->getSetting("attributesToIgnoreAtStart", 
				BehaviorClusteringPlugIn::name()));
	
	m_AttributesToIgnoreAtEnd = 
		BehaveRT::StringConverter::parseInt(
			m_CommonRes.getConfig()->getSetting("attributesToIgnoreAtEnd", 
				BehaviorClusteringPlugIn::name()));

	// Features

	m_FeaturesVector = new BehaveRT::DeviceArrayWrapper<float>(
		m_CommonRes.getDeviceInterface(), hBody3DParams.numBodies, 
		hBehaviorClusteringParams.featuresCount);
	m_FeaturesVector->bindToField(hBehaviorClusteringFields.featuresVector);

	m_SimilarityStats = new BehaveRT::DeviceArrayWrapper<float4>(
		m_CommonRes.getDeviceInterface(), hBody3DParams.numBodies);
	m_SimilarityStats->bindToField(hBehaviorClusteringFields.similarityStats);

	m_ClusterMembership = new BehaveRT::DeviceArrayWrapper<float3>(
		m_CommonRes.getDeviceInterface(), hBody3DParams.numBodies);
	m_ClusterMembership->bindToField(hBehaviorClusteringFields.clusterMembership);

	m_DatasetPath = m_CommonRes.getConfig()->getSetting("datasetPath", 
		BehaviorClusteringPlugIn::name());

	// ---------------
		// MOD 24-10-10
	m_CMConnector = new BehaveRT::DeviceArrayWrapper<float4>(
		m_CommonRes.getDeviceInterface(), 
		hBody3DParams.numBodies * 2, // Two values for each individual
		1, true, true); // VBO binding
	m_CMConnector->bindToField(hBehaviorClusteringFields.CMConnector);
	// ---------------


	m_NieghSimilarities = new BehaveRT::DeviceArrayWrapper<float4>(
			m_CommonRes.getDeviceInterface(), m_NieghList->getSize());

	m_NieghSimilarities->bindToField(hBehaviorClusteringFields.neighSimilarities);


	// When you want to transfert params and fields to device
	// use this function:
	BehaviorClustering::BehaviorClustering_copyFieldsToDevice();

	//char msg[100];
	//sprintf(msg, "NeighSimSize: %d, %d\n\n", 
	//	m_NieghList->getSize(),
	//	 m_NieghList->getSize(), m_NieghList->getBytesCount());
	//	m_CommonRes.getLogger()->log(name(), msg);
	
	// Set not-default rendering shaders
	setGIShaders(BCVertexShader, BCPixelShader);

	m_ShowClusterMembershipStats = false;

}

// --------------------------------------------------------------

template <class Super>
void BehaviorClusteringPlugIn<Super>::uninstall()
{
	// Put here memory deallcation
	// Example
	// delete m_AgentHash

	delete m_FeaturesVector;
	delete m_SimilarityStats;
}

// --------------------------------------------------------------

static void copyArray(float source[], float dest[], int n)
{
	if (n == 0) return;
	for (int i = 0; i < n; i ++) { dest[i] = source[i]; }
}

static float getNormalizedValue(float originalValue, float mean, float deviation)
{
	return (originalValue - mean) / deviation;
}

static void normalizeVector(float vector[], int n, float mean, float deviation)
{
	for (int i = 0; i < n; i ++) { vector[i] = getNormalizedValue(vector[i], mean, deviation); }	
}

static float getDeviationItem(float item, float mean) 
{
	return (item - mean) * (item - mean);
}

static float getDeviation(float squaredSum, int n) 
{
	return sqrt( squaredSum / (n - 1) );
}

static void normalizeVector(float vector[], int n)
{
	if (n == 0) return;

	float mean = 0.0f, deviation = 0.0f;
	for (int i = 0; i < n; i ++) { mean += vector[i]; }
	mean /= n;
	for (int i = 0; i < n; i ++) { deviation += (vector[i] - mean) * (vector[i] - mean); }
	deviation = sqrt( deviation / (n - 1) );

	normalizeVector(vector, n, mean, deviation);
}

/*
static void normalizeVector(float vector[], int n)
{
	if (n == 0) return;

	float mean = 0.0f, deviation = 0.0f;
	for (int i = 0; i < n; i ++) { mean += vector[i]; }
	mean /= n;
	for (int i = 0; i < n; i ++) { deviation += (vector[i] - mean) * (vector[i] - mean); }
	deviation = sqrt( deviation / (n - 1) );

	normalizeVector(vector, n, mean, deviation);
}
*/

// --------------------------------------------------------------

void loadSinteticData(
	BehaveRT::DeviceArrayWrapper<float4>* m_Pos,
	BehaveRT::DeviceArrayWrapper<float>* m_FeaturesVector,
	BehaveRT::DeviceArrayWrapper<float4>* m_Color,
	int &m_ElementsNumber)
{
	m_ElementsNumber = 0;

	for (BehaveRT::uint i = 0; i < hBody3DParams.numBodies; i ++ )
	{
		float* initClusterMembership = new float[
			hBehaviorClusteringParams.featuresCount];
		float4 initColor;

		if (i < hBody3DParams.numBodies / 4)
		{
			float featuresValues[] = {1, 0, 0, 0, 0, 0};
			copyArray(featuresValues, initClusterMembership, 
				hBehaviorClusteringParams.featuresCount);
			initColor = make_float4(1, 0, 0, 1);

		}
		else if (i < hBody3DParams.numBodies * 2 / 4)
		{
			float featuresValues[] = {0, 1, 0, 0, 0, 1};
			copyArray(featuresValues, initClusterMembership, 
				hBehaviorClusteringParams.featuresCount);
			initColor = make_float4(0, 1, 0, 1);
		}
		else if (i < hBody3DParams.numBodies * 3 / 4)
		{
			float featuresValues[] = {0, 0, 1, 0, 0, 0};
			copyArray(featuresValues, initClusterMembership, 
				hBehaviorClusteringParams.featuresCount);
			initColor = make_float4(0.7, 0.7, 0.1, 1);
		}
		else
		{
			float featuresValues[] = {0.9f, 0, 0, 0, 0, 0};
			copyArray(featuresValues, initClusterMembership, 
				hBehaviorClusteringParams.featuresCount);
			initColor = make_float4(0, 0, 1, 1);
		}

		m_Color->setHostArrayElement(i, &initColor);
		m_FeaturesVector->setHostArrayElement(i, initClusterMembership);

		hBehaviorClusteringParams.elementsNumber ++;
	}

	m_FeaturesVector->copyArrayToDevice();
	m_FeaturesVector->swapPosReadWrite();
	m_Color->copyArrayToDevice();
	m_Color->swapPosReadWrite();
}


static void loadDataset(
	std::string fileName,
	BehaveRT::DeviceArrayWrapper<float4>* m_Pos,
	BehaveRT::DeviceArrayWrapper<float>* m_FeaturesVector,
	BehaveRT::DeviceArrayWrapper<float4>* m_Color,
	BehaveRT::DeviceArrayWrapper<float3>* m_ClusterMembership,
	int m_AttributesToIgnoreAtStart, 
	std::string pluginName, 
	int &m_ElementsNumber,
	bool normalizeGlobally, bool normalizeLocally) 
{

	ifstream dataFile;    // Create an input file stream.
	dataFile.open(fileName.c_str());

    if ( ! dataFile ) {
       cout << "Error: Can't open the file named " << fileName << ".\n";
	   system("pause");
    }

	string dataFileLine;
	std::vector<std::string> clusterLabels;

	std::vector<std::string> clusterMembershipTemp;
	
	m_ElementsNumber = 0;

	BehaveRT::uint individualIndex = 0;
	for (individualIndex = 0; individualIndex < hBody3DParams.numBodies; individualIndex ++ )
	{
		getline(dataFile, dataFileLine);
		if (!dataFile)
			break;

		float* initClusterMembership = new float[
			hBehaviorClusteringParams.featuresCount];
		float4 initColor;

		string featureValueString;
		stringstream dataFileLineStream(dataFileLine); // Insert the string into a stream
		int featureIndex = 0;

		while (dataFileLineStream >> featureValueString)
		{
			if (featureIndex < m_AttributesToIgnoreAtStart)
			{
				featureIndex ++;
				continue;
			}
	
			if (featureIndex >= hBehaviorClusteringParams.featuresCount)
				break;

			initClusterMembership[featureIndex] =
				BehaveRT::StringConverter::parseFloat(featureValueString);

			featureIndex ++;
		}

		vector<std::string>::iterator clusterLabelsIt = 
			find(clusterLabels.begin(), clusterLabels.end(), featureValueString);

		if (clusterLabelsIt == clusterLabels.end() && featureValueString != "")
		{
			clusterLabels.push_back(featureValueString);
		}

		clusterMembershipTemp.push_back(featureValueString);
		
		float clusterIndex = (float)(clusterLabels.end() - clusterLabelsIt);

		float3 clusterMembership = make_float3(
			-1.0, 0.0f, clusterIndex);

		m_FeaturesVector->setHostArrayElement(individualIndex, initClusterMembership);
		m_ElementsNumber ++;

	} // Individuals

	// -------------------------------------------------------------------
	// Data normalization

	float* attributeMean = new float[
			hBehaviorClusteringParams.featuresCount];
	float* attributeDevSt = new float[
			hBehaviorClusteringParams.featuresCount];

	// -------------------------
	// Local normalization (if active) and means gathering
	if (normalizeGlobally || normalizeLocally)

		cout << "Data Normalization ENABLED\n";
		
		for (individualIndex = 0; individualIndex < m_ElementsNumber; individualIndex ++ )
		{
			float* individualAttributes = 
				individualAttributes = m_FeaturesVector->
					getHostArrayElementRef(individualIndex);
			
			if (normalizeLocally)
			{
				normalizeVector(
					individualAttributes,
					hBehaviorClusteringParams.featuresCount);
			}

			// Normalize globally
			// Compute avgs and DevSts
			if (normalizeGlobally)
				for (int i = 0; i < hBehaviorClusteringParams.featuresCount; i ++) 
				{
					attributeMean[i] += individualAttributes[i];
				}
		} // Individuals


	// -------------------------
	// Means finalization
	if (normalizeGlobally)
		for (int i = 0; i < hBehaviorClusteringParams.featuresCount; i ++) 
		{
			attributeMean[i] /= hBehaviorClusteringParams.featuresCount;
		}

	// -------------------------
	// Standard deviations gathering

	if (normalizeGlobally)
		for (individualIndex = 0; individualIndex < m_ElementsNumber; individualIndex ++ )
		{
			float* individualAttributes = 
				individualAttributes = m_FeaturesVector->
					getHostArrayElementRef(individualIndex);

			for (int i = 0; i < hBehaviorClusteringParams.featuresCount; i ++) 
			{
				attributeDevSt[i] += getDeviationItem(
					individualAttributes[i], attributeMean[i]);
			}
		}
	
	// -------------------------
	// Standard deviations finalization

	if (normalizeGlobally)
		for (int i = 0; i < hBehaviorClusteringParams.featuresCount; i ++) 
		{
			attributeDevSt[i] = getDeviation(attributeDevSt[i], 
				hBehaviorClusteringParams.featuresCount);
		}

	// -------------------------
	// Normalization

	if (normalizeGlobally)
		for (individualIndex = 0; individualIndex < m_ElementsNumber; individualIndex ++ )
		{
			float* individualAttributes = 
				individualAttributes = m_FeaturesVector->
					getHostArrayElementRef(individualIndex);

			for (int i = 0; i < hBehaviorClusteringParams.featuresCount; i ++) 
			{
				individualAttributes[i] = getNormalizedValue(
					individualAttributes[i], attributeMean[i], attributeDevSt[i]);
			}
		}

	char msg[150];

	// Print dataset info to screen
	sprintf(msg, "Dataset path: %s\n\t#Elements num: %d; #Attributes: %d; #Clusters: %d;\n", 
		fileName.c_str(), m_ElementsNumber, 
		hBehaviorClusteringParams.featuresCount,
		clusterLabels.size());

	m_CommonRes.getLogger()->log(pluginName, msg);

	
	// -------------------------------------------------------------------
	// Cluster membership

	for (int index = 0; index < individualIndex; index ++ )
	{
		std::string featureValueString = clusterMembershipTemp[index];
		vector<std::string>::iterator clusterLabelsIt = 
			find(clusterLabels.begin(), clusterLabels.end(), featureValueString);

		
		float clusterIndex = (float)(clusterLabels.end() - clusterLabelsIt);
		float3 clusterMembership = make_float3(
			-1.0, 0.0f, clusterIndex);

		float redVal = (clusterIndex - 1) / (clusterLabels.size() - 1);
		float greenVal = 1.0f - redVal;
		float blueVal = 0.0f; //1.0f - redVal;
		
		float4 initColor = make_float4(redVal, greenVal, blueVal, 1.0f);
		
		m_Color->setHostArrayElement(index, &initColor);
		m_ClusterMembership->setHostArrayElement(index, &clusterMembership);
	}

	m_ClusterMembership->copyArrayToDevice();
	m_ClusterMembership->swapPosReadWrite();

	clusterMembershipTemp.clear();

	for (; individualIndex < hBody3DParams.numBodies; individualIndex ++ )
	{
		//cout << "DELETED " << individualIndex << "\n";
		int multipler = 100000;
		float4 initPos = make_float4(
			hEnvGrid3DParams.worldRadius.x * multipler, 
			hEnvGrid3DParams.worldRadius.y * multipler, 
			hEnvGrid3DParams.worldRadius.z * multipler, 1);

		m_Pos->setHostArrayElement(individualIndex, &initPos);
	}
	

	dataFile.close();

	m_Pos->copyArrayToDevice();
	m_Pos->swapPosReadWrite();
	m_FeaturesVector->copyArrayToDevice();
	m_FeaturesVector->swapPosReadWrite();
	m_Color->copyArrayToDevice();
	m_Color->swapPosReadWrite();
}

template <class Super>
void BehaviorClusteringPlugIn<Super>::reset()
{
	Super::reset(); // MANDATORY OPERATION

	// Initi the position
	for (BehaveRT::uint i = 0; i < hBody3DParams.numBodies; i ++ )
	{
		float4 initVal = make_float4(
			1.0, 0.5, 0.0, 0.0);

		m_SimilarityStats->setHostArrayElement(i, &initVal);

		// ---------------------------------

		float3 unitRand = make_float3(
			frand() - 0.5, frand() - 0.5, frand() - 0.5);
		float multipler = 2;

		float4 initPos = make_float4(
			(unitRand.x) * hEnvGrid3DParams.worldRadius.x * multipler + hEnvGrid3DParams.worldCenter.x, 
			(unitRand.y) * hEnvGrid3DParams.worldRadius.y * multipler + hEnvGrid3DParams.worldCenter.y, 
			(unitRand.z) * hEnvGrid3DParams.worldRadius.z * multipler + hEnvGrid3DParams.worldCenter.z, 
			1);

		m_Pos->setHostArrayElement(i, &initPos);
	}

	m_SimilarityStats->copyArrayToDevice();
	m_SimilarityStats->swapPosReadWrite();

	m_Pos->copyArrayToDevice();
	m_Pos->swapPosReadWrite();
	
	
	bool normalizeGlobally = BehaveRT::StringConverter::parseBool(
		m_CommonRes.getConfig()->getSetting("normalizeGlobally", 
			BehaviorClusteringPlugIn::name()));

	//bool normalizeLocally = !normalizeGlobally;
	bool normalizeLocally = BehaveRT::StringConverter::parseBool(
		m_CommonRes.getConfig()->getSetting("normalizeLocally", 
			BehaviorClusteringPlugIn::name()));


	// Init Features
	loadDataset(m_DatasetPath, m_Pos, m_FeaturesVector, m_Color,
		m_ClusterMembership, m_AttributesToIgnoreAtStart, 
		name(), hBehaviorClusteringParams.elementsNumber, 
		normalizeGlobally, normalizeLocally);
	//loadSinteticData(m_Pos, m_FeaturesVector, m_Color);


	for (BehaveRT::uint i = 0; i < hBody3DParams.numBodies * 2; i ++ )
	{
		float multipler = 5000;

		float4 initPos = make_float4(
			hEnvGrid3DParams.worldRadius.x * multipler, 
			hEnvGrid3DParams.worldRadius.y * multipler, 
			hEnvGrid3DParams.worldRadius.z * multipler, 
			1);
		m_CMConnector->setHostArrayElement(i, &initPos);
	}

	m_CMConnector->copyArrayToDevice();
	m_CMConnector->swapPosReadWrite();
	m_CMConnector->copyArrayToDevice();
	m_CMConnector->swapPosReadWrite();

	

	// --------------------------

	m_ParamListGL->AddParam(
		new Param<float>("Cluster cohesion W", 
			hBehaviorClusteringParams.clusteringForceParams.x, 
			0.0, 20.0, 0.5, 
			&hBehaviorClusteringParams.clusteringForceParams.x));

	m_ParamListGL->AddParam(
		new Param<float>("Cluster alignment W", 
			hBehaviorClusteringParams.alignmentClusteringForceParams.x, 
			0.0, 20.0, 0.5, 
			&hBehaviorClusteringParams.alignmentClusteringForceParams.x));

	m_ParamListGL->AddParam(
		new Param<float>("sim <---> asim", 
			hBehaviorClusteringParams.avgSimilarityController, 
			0.0, 1.0, 0.1, 
			&hBehaviorClusteringParams.avgSimilarityController));

	//------------------
	// MOD 23,23-10-10

	hBehaviorClusteringParams.iterationLP = 10;
	m_ParamListGL->AddParam(
		new Param<int>("LPIterations", 
			hBehaviorClusteringParams.iterationLP, 
			0.0, 50.0, 1.0, 
			&hBehaviorClusteringParams.iterationLP));

	// ----------------------------
	// Set the needed of bodies

	m_NeededNumBodies = 
		(1 + (int)(hBehaviorClusteringParams.elementsNumber / 
			m_CommonRes.getDeviceInterface()->getHostSimParams().commonBlockDim)) * 
				m_CommonRes.getDeviceInterface()->getHostSimParams().commonBlockDim;

	hBody3DParams.numBodies = m_NeededNumBodies;

	char msg[100];
	sprintf(msg, "hBody3DParams.numBodies set to: %d\n", 
		m_NeededNumBodies);
	m_CommonRes.getLogger()->log(name(), msg);

}

// --------------------------------------------------------------

template <class Super>
void BehaviorClusteringPlugIn<Super>::update(const float elapsedTime)
{
	Super::update(elapsedTime); // MANDATORY OPERATION

	// Insert here the default update operation
}

// --------------------------------------------------------------
// --------------------------------------------------------------

template <class Super>
void BehaviorClusteringPlugIn<Super>::steerForClustering2()
{
	EnvGrid3D::EnvGrid3D_copyFieldsToDevice();
	OpenSteerWrapper::OpenSteerWrapper_copyFieldsToDevice();
	BehaviorClustering::BehaviorClustering_copyFieldsToDevice();

	m_CommonRes.getDeviceInterface()->kernelCall(
		hBody3DParams.numBodies, 
		m_CommonRes.getDeviceInterface()->getHostSimParams().commonBlockDim,
		BehaviorClustering_steerForClusteringRef(), 
		&BehaviorClustering_beforeKernelCall, 
		&BehaviorClustering_afterKernelCall);

	m_SteerForce->swapPosReadWrite();
	//m_Color->swapPosReadWrite();
	m_SimilarityStats->swapPosReadWrite();
}

template <class Super>
void BehaviorClusteringPlugIn<Super>::steerForClustering()
{
	EnvGrid3D::EnvGrid3D_copyFieldsToDevice();
	OpenSteerWrapper::OpenSteerWrapper_copyFieldsToDevice();
	BehaviorClustering::BehaviorClustering_copyFieldsToDevice();

	/*m_CommonRes.getDeviceInterface()->kernelCall(
		hBody3DParams.numBodies, 
		m_CommonRes.getDeviceInterface()->getHostSimParams().commonBlockDim,
		//32, 
		BehaviorClustering_computeNeighSimilaritiesRef(), 
		&BehaviorClustering_beforeKernelCall, 
		&BehaviorClustering_afterKernelCall);

	m_NieghSimilarities->swapPosReadWrite();
	m_SimilarityStats->swapPosReadWrite();*/

	//m_SmoothedColor->swapPosReadWrite();

	int multiplicator = 
		((hProximity3DParams.maxNeighbors + 1) * (hProximity3DParams.maxNeighbors + 1)) /
			m_CommonRes.getDeviceInterface()->getHostSimParams().commonBlockDim;
	// Laungh one block for each individual
	/*m_CommonRes.getDeviceInterface()->kernelCall(
		//hBody3DParams.numBodies,
		//hBody3DParams.numBodies * multiplicator, 
		hBody3DParams.numBodies * (hProximity3DParams.maxNeighbors + 1), 
		//m_CommonRes.getDeviceInterface()->getHostSimParams().commonBlockDim,
		(hProximity3DParams.maxNeighbors + 1),
		BehaviorClustering_computeNeighNaiveSimilarities_shrdRef(), 
		&BehaviorClustering_beforeKernelCall, 
		&BehaviorClustering_afterKernelCall);*/

	m_CommonRes.getDeviceInterface()->kernelCall(
		hBody3DParams.numBodies,
		m_CommonRes.getDeviceInterface()->getHostSimParams().commonBlockDim,
		BehaviorClustering_computeNeighNaiveSimilaritiesRef(), 
		&BehaviorClustering_beforeKernelCall, 
		&BehaviorClustering_afterKernelCall);

	m_NieghSimilarities->swapPosReadWrite();

	m_CommonRes.getDeviceInterface()->kernelCall(
		hBody3DParams.numBodies, 
		m_CommonRes.getDeviceInterface()->getHostSimParams().commonBlockDim,
		BehaviorClustering_computeAdaptiveSimilaritiesRef(), 
		&BehaviorClustering_beforeKernelCall, 
		&BehaviorClustering_afterKernelCall);

	m_NieghSimilarities->swapPosReadWrite();
	m_SimilarityStats->swapPosReadWrite();
	
	// --------------------------------
	// DEBUG

	//steerForClustering2();
	//m_NieghSimilarities->swapPosReadWrite();
	//m_SteerForce->swapPosReadWrite();

	// --------------------------------

	m_CommonRes.getDeviceInterface()->kernelCall(
		hBody3DParams.numBodies, 
		m_CommonRes.getDeviceInterface()->getHostSimParams().commonBlockDim,
		BehaviorClustering_steerForClusterCohesionRef(), 
		&BehaviorClustering_beforeKernelCall, 
		&BehaviorClustering_afterKernelCall);

	m_SteerForce->swapPosReadWrite();

	m_CommonRes.getDeviceInterface()->kernelCall(
		hBody3DParams.numBodies, 
		m_CommonRes.getDeviceInterface()->getHostSimParams().commonBlockDim,
		BehaviorClustering_steerForClusterAlignmentRef(), 
		&BehaviorClustering_beforeKernelCall, 
		&BehaviorClustering_afterKernelCall);

	m_SteerForce->swapPosReadWrite();


	
	
}

//------------------
// MOD 23,24-10-10

template <class Super>
void BehaviorClusteringPlugIn<Super>::computeClusterMembership()
{
	// Local propagtion algorithm 

	// Initialization
	m_CommonRes.getDeviceInterface()->kernelCall(
		hBody3DParams.numBodies, 
		m_CommonRes.getDeviceInterface()->getHostSimParams().commonBlockDim,
		BehaveRT_getKernelRef(BehaviorClustering_resetClusterMembership_kernel), 
		&BehaviorClustering_beforeKernelCall, 
		&BehaviorClustering_afterKernelCall);

	m_ClusterMembership->swapPosReadWrite();

	// Refresh localPropIterations' value
	BehaviorClustering::BehaviorClustering_copyFieldsToDevice();

	// Itearative process
	for (int i = 0; i < hBehaviorClusteringParams.iterationLP; i ++)
	{
		m_CommonRes.getDeviceInterface()->kernelCall(
			hBody3DParams.numBodies, 
			m_CommonRes.getDeviceInterface()->getHostSimParams().commonBlockDim,
			BehaveRT_getKernelRef(BehaviorClustering_computeClusterMembership_kernel), 
			&BehaviorClustering_beforeKernelCall, 
			&BehaviorClustering_afterKernelCall);

		m_ClusterMembership->swapPosReadWrite();
	}

	// Create a connection <individual, cluster membership>
	m_CommonRes.getDeviceInterface()->kernelCall(
		hBody3DParams.numBodies, 
		m_CommonRes.getDeviceInterface()->getHostSimParams().commonBlockDim,
		BehaveRT_getKernelRef(BehaviorClustering_CMConnection_kernel), 
		&BehaviorClustering_beforeKernelCall, 
		&BehaviorClustering_afterKernelCall);

	m_CMConnector->swapPosReadWrite();

	m_CommonRes.getDeviceInterface()->threadSync();
	

} // computeClusterMembership

template <class Super>
void BehaviorClusteringPlugIn<Super>::drawClusterMemberships()
{
	m_CommonRes.getDeviceInterface()->threadSync();

	renderBillboards(m_CMConnector->getReadVbo(), 
		GL_LINES, false,  hBody3DParams.numBodies * 2);
}

//------------------

template <class Super>
void BehaviorClusteringPlugIn<Super>::analyzeClusterHitRate()
{
	m_CommonRes.getDeviceInterface()->kernelCall(
		hBody3DParams.numBodies, 
		m_CommonRes.getDeviceInterface()->getHostSimParams().commonBlockDim,
		BehaveRT_getKernelRef(BehaviorClustering_clusterHitRate), 
		&BehaviorClustering_beforeKernelCall, 
		&BehaviorClustering_afterKernelCall);

	m_ClusterMembership->swapPosReadWrite();

	

	/*
	if (!m_ShowClusterMembershipStats)
		return; 
		
	m_ClusterMembership->copyArrayFromDevice();

	float avgHitRate = 0.0f;
	for (int i = 0; i < getElementsNumber(); i ++)
	{
		float3 clusterMembership = 
			m_ClusterMembership->getHostArrayElement(i);

		avgHitRate += clusterMembership.y;

		if (clusterMembership.y < 0.5)
		{
			cout << "\t" << i << ") " << 
				clusterMembership.x << " " << 
				clusterMembership.y << " " <<
				clusterMembership.z << "\n";
		}
	}

	avgHitRate /= getElementsNumber();

	cout << avgHitRate << "\n";*/
}

// --------------------------------------------------------------
// --------------------------------------------------------------

template <class Super>
void BehaviorClusteringPlugIn<Super>::mergeClusters()
{
	
	if (hBehaviorClusteringParams.mergeClusterLeaders[0] ==
		hBehaviorClusteringParams.mergeClusterLeaders[1])
		return;

	m_CommonRes.getDeviceInterface()->kernelCall(
		hBody3DParams.numBodies, 
		m_CommonRes.getDeviceInterface()->getHostSimParams().commonBlockDim,
		BehaveRT_getKernelRef(BehaviorClustering_MergeClusters_kernel), 
		&BehaviorClustering_beforeKernelCall, 
		&BehaviorClustering_afterKernelCall);

	m_Forward->swapPosReadWrite();

	cout << "BehaviorClusteringPlugIn::Merge [" << 
		hBehaviorClusteringParams.mergeClusterLeaders[0] << " - " <<
		hBehaviorClusteringParams.mergeClusterLeaders[1] << "]" << endl;

	hBehaviorClusteringParams.mergeClusterLeaders[0] = 0;
	hBehaviorClusteringParams.mergeClusterLeaders[1] = 0;
}

// --------------------------------------------------------------
// --------------------------------------------------------------

template <class Super>
void BehaviorClusteringPlugIn<Super>::freezeClusters()
{
	if (hBehaviorClusteringParams.freezeClusterLeader == 0)
		return;
	
	cout << "BehaviorClusteringPlugIn::Freeze [" << 
		hBehaviorClusteringParams.freezeClusterLeader << "]" << endl;
	
	hBehaviorClusteringParams.freezeClusterLeader = 0;
}
